<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise学习笔记]]></title>
    <url>%2F2018%2F06%2F10%2FPromise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是Promise？Promise是es6新增的异步编程的一种解决方案，是es6的原生对象。它有三种状态： pending 进行中 resolved 已完成 rejected 已失败当Promise的状态由pending转变为resolved时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态。 用法 用函数包装异步操作，返回Promise对象： 123456789101112131415161718192021function run1()&#123; var p = new Promise((resolve,reject)=&gt;&#123; //这里做一些异步操作 setTimeout(()=&gt;&#123; console.log('第一个run'); resolve('第一个run已完成');//resolve代表异步操作执行成功后的回调函数 &#125;,10000) &#125;); return p; &#125; function run2()&#123; var p = new Promise((resolve,reject)=&gt;&#123; //这里做一些异步操作 setTimeout(()=&gt;&#123; console.log('第二个run'); resolve('第二个run已完成');//resolve代表异步操作执行成功后的回调函数 &#125;,10000) &#125;); return p; &#125; 链式操作： 12345678910run1().then((data)=&gt;&#123; //then中放的语句是等run执行完毕后才执行的 console.log(data);//这个data是resolve(xxx)中传入的xxx return run2();//这里run2的返回值也是一个Promise对象，它的resolve会传给下一个then&#125;).then((data)=&gt;&#123; console.log(data); return "结束了";//也可以直接把数据传给下一个then&#125;).then((data)=&gt;&#123; console.log(data);//接收到上一个then return的数据&#125;) reject怎么用？resolve是已完成后的回调函数，reject是已失败后的回调函数。reject就是把Promise的状态置为rejected，然后在then中捕捉到，或者用catch捕捉，执行“失败”的回调。把代码改为： 12345678910111213141516171819202122 function run1(a)&#123; var p = new Promise((resolve,reject)=&gt;&#123; //这里做一些异步操作 setTimeout(()=&gt;&#123; console.log('第一个run'); if(a === 'reject')&#123; reject('第一个run已失败');//reject代表异步操作执行失败后的回调函数 &#125;else&#123; resolve('第一个run已完成');//resolve代表异步操作执行成功后的回调函数 &#125; &#125;,10000) &#125;); return p; &#125;run1('reject').then((data)=&gt;&#123; console.log('resolved'); console.log(data); &#125;,(reason)=&gt;&#123;//then的第二个参数捕捉reject console.log('rejected'); console.log(reason); &#125;) 或者用catch来捕捉reject并制定reject的回调：1234567run1('reject').then((data)=&gt;&#123; console.log('resolved'); console.log(data); &#125;).catch((reason)=&gt;&#123; console.log('rejected'); console.log(reason); &#125;) 用catch的好处是：resolve回调抛出异常时，不会报错卡死JS，而是会进到这个catch方法中。 all的用法：Promise.all接收一个函数数组参数，里面的值最终都返回Promise对象。数组中的异步操作并行执行，等它们都执行完后才会进到then里面，all会把所有的异步操作的结果放进一个数组中传给then;如果执行失败，则返回最先被reject的结果值。123Promise.all([run1(),run2(),run3()]).then((result)=&gt;&#123; console.log(result);&#125;) race的用法：all的执行顺序是按数组下标先后执行，但race是哪个执行得快先返回哪个结果值。1234567891011121314151617181920212223242526272829function run1(a)&#123; var p = new Promise((resolve,reject)=&gt;&#123; //这里做一些异步操作 setTimeout(()=&gt;&#123; console.log('第一个run'); if(a === 'reject')&#123; reject('第一个run已失败');//reject代表异步操作执行失败后的回调函数 &#125;else&#123; resolve('第一个run已完成');//resolve代表异步操作执行成功后的回调函数 &#125; &#125;,10000) &#125;); return p; &#125; function run2()&#123; var p = new Promise((resolve,reject)=&gt;&#123; //这里做一些异步操作 setTimeout(()=&gt;&#123; console.log('第二个run'); resolve('第二个run已完成');//resolve代表异步操作执行成功后的回调函数 &#125;,5000) &#125;); return p; &#125; Promise.race([run1(),run2()]).then((result)=&gt;&#123; console.log(result); &#125;) 打印结果，可以看到，上面的代码run2先被执行，因为run2更快。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象代理（数据隐私保护）]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学c++和java的时候，我们都可以快速方便地定义私有属性，但在js里面要定义私有属性就比较麻烦了。 es5中可以依靠Object.defineProperty()这个方法定义私有属性。12345678910111213141516var Person = &#123; name:'haha', age:15 &#125; Object.defineProperty(Person,'sex',&#123; writable:false,//设为只读 value:'male' &#125;); try&#123; Person.sex = 'female'; console.log(Person.sex);//sex属性还是male，并没有被改掉 &#125;catch(e)&#123; console.log(e); &#125; 在es6中我们可以使用对象代理,中间加个代理层来定义私有属性。1234567891011121314151617181920212223let Person = &#123; name:'haha', sex:'male', age:15 &#125;; let person = new Proxy(Person,&#123; get(target,key)&#123; return target[key] &#125;, set(target,key,value)&#123; if(key!=='sex')&#123; target[key]=value; &#125; &#125; &#125;); try&#123; person.sex = 'female'; console.log(Person.sex);//sex属性还是male，并没有被改掉 &#125;catch(e)&#123; console.log(e); &#125; Proxy是es6提供的新方法。使用代理的方式，用户操作的其实是person，而不是Person，这种方式可以在代理层中定义很多逻辑复杂的拦截规则，但是不会影响原始对象数据，是个很好的方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[默认参数]]></title>
    <url>%2F2018%2F06%2F09%2F%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ES5中,如果函数调用时没有传入参数，需要使用默认的参数值时需要这么写：123456789101112function f(x,y,z)&#123; if(x === undefined)&#123; x = 7; &#125; if(y === undefined)&#123; y = 6; &#125; if(z === undefined)&#123; z = 5; &#125; return x+y+z;&#125; 在es6中就方便多了，可以直接写成这样：123function f(x=7,y=6,z=5)&#123; return x+y+z;//当x，y，z等于undefined时自动附上默认值&#125; es6可变参数：如果函数传入的参数个数不确定时，es6中可以这么写：12345678function f(...a)&#123; var sum = 0; a.forEach(item =&gt; &#123; sum += item; &#125;); return sum;&#125;console.log(f(1,2,3,4));//打印10]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数写法：123()=&gt;&#123;&#125; ()里面放参数，当参数只有一个时，()可以省略；如果{}的表达式全部座位返回值时，{}也可省略。例：12let events = [1,2,3,4,5];let adds = events.map(v=&gt;v+1); 等价于：12let events = [1,2,3,4,5];let adds = events.map(function(v)&#123;return v+1&#125;) 箭头函数与function的主要区别在于this的绑定。function的this是在执行时进行绑定的，而箭头函数的this是在声明时进行绑定的，这样避免了this指向不明确的问题。最典型的例子：12345678var x=11;var obj = &#123; x:22, y:function()&#123; console.log(this.x); &#125;&#125;console.log(obj.y); 打印出来是22，function的this在执行时绑定，绑定的是调用属性的对象，也就是obj自身的x，所以结果是22。1234567var x = 11;var obj = &#123; x:22, y:()=&gt;&#123; console.log(this.x); &#125;&#125; 打印出来是11，因为箭头函数的this在声明时绑定，取x的值为11，所以结果是11。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6块级作用域]]></title>
    <url>%2F2018%2F06%2F09%2Fes6%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[ES5中，没有块级作用域，所以会出现以下情况：123456789101112var callbacks = [];for(var i=0;i&lt;=2;i++)&#123; callbacks[i] = function()&#123; return i * 2; &#125;&#125;console.table([ callbacks[0](), callbacks[1](), callbacks[2](),]) 这段代码的结果是输出3个6。 首先var i=0这一句话，将i做了一个变量提升，i是一个跟callbacks平级的变量；然后进行for循环，for 循环结束时，i的值已经被更新成为了3；由于function(){return i*2}不是立即被调用的，而是循环结束后，也就是i等于3的时候才调用的，它执行的时候会去找它上一级作用域中i的值，发现i等于3，于是进行计算并输出，所以callbacks[0](),callbacks[1](),callbacks[2]()的结果全部都是6。 ES6中我们可以用let来声明变量，将变量的作用域限定为块级作用域，不存在变量提升：123456789101112const callbacks = [];for(let i=0;i&lt;=2;i++)&#123; callbacks[i] = function()&#123; return i * 2; &#125;&#125;console.table([ callbacks[0](), callbacks[1](), callbacks[2](),]) 结果为0，2，4。let声明的变量为块作用域，作用于当前块；每次循环都会把值保留下来供后面的闭包使用。这段for循环等价于：1234567for (let i = 0; i &lt; 10; i++) &#123; a[i] = (function(i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125; 在ES6中只需一个花括号就可以指定块作用域。123456789101112131415&#123; function foo()&#123; return 1; &#125; console.log(foo() === 1); &#123; function foo()&#123; return 2; &#125; console.log(foo() === 2); &#125; console.log(foo() === 1);&#125; 结果是打印3个true。可见两个作用域没有相互影响，一对花括号就已经把作用域隔离。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6常量]]></title>
    <url>%2F2018%2F06%2F06%2Fes6%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在ES5中，一般利用window对象来定义常量，思路是将变量绑在window上，并设为只读状态。 代码：12345Object.defineProperty(window,"PI",&#123; value:3.14, writeable:false,//只读&#125;);console.log(window.PI); ES6中，则可以直接通过const来声明常量。12const PI = 3.14;console.log(PI);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue双向数据绑定原理]]></title>
    <url>%2F2018%2F05%2F31%2FVue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是双向数据绑定？Vue是个MVVM框架，当数据发生变化时，视图也跟着发生变化，当视图发生变化时，数据也会跟着同步变化。双向数据绑定，一般是对于UI控件来说的，非UI控件不会涉及到双向数据绑定。 Vue双向数据绑定是怎么实现的？官方文档上说得很简单——用v-model指令在表单元素上创建双向数据绑定。那么，v-model背后的实现原理又是什么呢？它的基本原理是利用Object.defineProperty()这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。使用Object.defineProperty()实现一个简单的双向数据绑定小例子：123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="text" type="text" /&gt; &lt;p id="p"&gt;&lt;/p&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var obj = &#123;&#125;; Object.defineProperty(obj,"name",&#123; get:function()&#123; return name; &#125;, set:function(value)&#123; document.getElementById("text").value = value; document.getElementById("p").innerHTML = value; &#125; &#125;); var input = document.getElementById("text"); input.addEventListener("input",function(event)&#123; var text = event.target.value; obj.name = text; &#125;); &lt;/script&gt;&lt;/html&gt; 效果： 可以看到，我们在输入框输入内容时，标签内会显示对应的内容，这说明实现了model=&gt;view的绑定。现在我们在控制台给obj.name赋值，发现赋值后输入框的内容变成了所赋的那个值： 说明实现了view=&gt;model的绑定。 当然vue的实现比这复杂得多，详细请查看网上大牛们的博客。 这种实现双向数据绑定的方法叫作数据劫持结合发布者-订阅者模式。 简单解释什么是数据劫持结合发布者-订阅者模式：1、数据劫持：在本例中，通过Object.defineProperty来劫持name属性的setter，getter，在数据变化时通知订阅者，触发相应的回调；2、发布者/订阅者：订阅者可定义为希望接收到通知的对象；发布者可定义为激活事件的对象。在本例中，文本输入框相当于一个订阅者，Obj相当于一个发布者。文本框通过addEventListener接收Obj给它的启动通知，触发相应的函数，进行视图更新。 一般来说，实际应用中会涉及多个订阅者，这时就需要一个消息订阅器来管理这些订阅者；另外还需要指令来初始化订阅者。详情及更复杂的例子可参考这篇博文：http://www.cnblogs.com/libin-1/p/6893712.html]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下更新npm报错]]></title>
    <url>%2F2018%2F05%2F13%2FMac%E4%B8%8B%E6%9B%B4%E6%96%B0npm%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[今天在mac下用命令：npm i -g npm更新npm版本报错，报错信息如下：解决方法：在命令前面加上sudo：1sodu npm i -g npm 安装成功。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 box-flex属性（弹性盒子）学习笔记]]></title>
    <url>%2F2018%2F05%2F13%2Fcss3%20box-flex%E5%B1%9E%E6%80%A7%EF%BC%88%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[弹性盒子是 CSS3 的一种新的布局模式。 当页面需要适应不同的屏幕大小以及设备类型时，使用弹性盒子布局模式可以确保元素拥有恰当的行为。 使用场景1将一个div划分成多份，每一份占有某比例的宽度，无论在任何大小的设备屏幕上，此比例都保持不变。代码：123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; &#125; .child_box_one&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:red; &#125; .child_box_two&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:blue; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 首先父元素必须添加必要的声明：display:box或者display:inline-box；三个并列的子元素每一个都声明了box-flex: 1;，这说明每一个子div都将占据父div的三分之一容量。结果： 使用场景2将一个div划分成多份，其中有一份的宽度是固定的，除定宽的这份之外其他的每一份占有余下容量的某比例的宽度，无论在任何大小的设备屏幕上，此比例都保持不变。代码：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; &#125; .child_box_one&#123; /*-moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1;*/ width:30px; background-color:red; &#125; .child_box_two&#123; -moz-box-flex: 2; -webkit-box-flex: 2; box-flex: 2; background-color:blue; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果：如图所示，第一个子div——child_box_one固定占有30px的宽度，剩下两个子div按2:1的比例分配父div宽度减掉30px后剩下的容量。 margin和padding的影响如果某一个子div增加了magin/padding的属性，应该是先用可分配宽度减去margin/padding的宽度，剩下的宽度再按相应的比例分配给不同的子div。代码：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; &#125; .child_box_one&#123; /*-moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1;*/ width:30px; background-color:red; &#125; .child_box_two&#123; -moz-box-flex: 2; -webkit-box-flex: 2; box-flex: 2; background-color:blue; margin:0 30px; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果：可以看到，定宽的红色div宽度不变，虽然我们只给蓝色div加了margin，但事实上蓝色div和黄色div的分配到的宽度都减少了。 父标签的可选属性:box-orientbox-orient用来确定子元素的方向，是横着排还是竖着走。可选的值有：horizontal | vertical | inline-axis | block-axis | inherit例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:400px; -moz-box-orient:vertical; -webkit-box-orient:vertical; -o-box-orient:vertical; box-orient:vertical; &#125; .child_box_one&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:red; width: 100px; &#125; .child_box_two&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:blue; width: 100px; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; width: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果：父div中设置box-orient:vertical;子div就变成纵向排列了。 父标签的可选属性:box-align直接看代码吧：box-align属性设置为top时：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; -moz-box-align:top; -webkit-box-align:top; -o-box-align:top; box-align:top; &#125; .child_box_one&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:red; height:100px; &#125; .child_box_two&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:blue; height:200px; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; height:100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果：可以看到三个子div是顶部对齐的。 box-align属性设置为center时：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; -moz-box-align:center; -webkit-box-align:center; -o-box-align:center; box-align:center; &#125; .child_box_one&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:red; height:100px; &#125; .child_box_two&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:blue; height:200px; &#125; .child_box_three&#123; -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; background-color:yellow; height:100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;1&lt;/div&gt; &lt;div class="child_box_two"&gt;2&lt;/div&gt; &lt;div class="child_box_three"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果： 可以看到，三个子div是居中对齐的。 父标签的可选属性:box-packbox-align控制了子div垂直方向上的对齐方式，box-pack则控制了子div水平方向上的对齐方式，可选值有：start | end | center | justify。例如：justify属性值控制子div两端对齐：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .father_box&#123; display: -moz-box; display: -webkit-box; display: box; height:300px; -moz-box-pack:justify; -webkit-box-pack:justify; -o-box-pack:justify; box-pack:justify; &#125; .child_box_one&#123; /*-moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1;*/ background-color:red; &#125; .child_box_two&#123; /*-moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1;*/ background-color:blue; &#125; .child_box_three&#123; /*-moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1;*/ background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="father_box"&gt; &lt;div class="child_box_one"&gt;hahahaha1&lt;/div&gt; &lt;div class="child_box_two"&gt;hahahaha2&lt;/div&gt; &lt;div class="child_box_three"&gt;hahahaha3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果：若将属性值改为end，效果则是： 参考文章：http://www.zhangxinxu.com/wordpress/2010/12/css-box-flex%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学render]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%88%9D%E5%AD%A6render%2F</url>
    <content type="text"><![CDATA[一般情况下，在vue中，我们定义组件时，都使用template（模板）来创建HTML，但如果我们的HTML需要使用javaScript来生成的话，应该怎么办? 1、render函数的使用意义渲染节点 2、示例官方文档给我们提供了一个很好理解的例子：我们需要创建一个这样的组件：&lt;anchored-heading :level=&quot;1&quot;&gt;Hello world!&lt;/anchored-heading&gt;当level传入1时，渲染出来的html内容就是&lt;h1&gt;Hello world&lt;/h1&gt;，传入2时，渲染出来的html内容就是&lt;h2&gt;Hello world&lt;/h2&gt;……很明显我们想渲染的节点标签不是写死在模板里的。使用render来实现该组件：1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 由子节点构成的数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) render是一个渲染函数，返回值是DOM节点。示例代码第三行：我们在createElement()这个函数里传了两个参数，第一个参数是节点名称，跟this.level挂钩，this.level是1，节点名称就是&lt;h1&gt;，是2节点名称就是&lt;h2&gt;，第二个参数是节点下的子节点，$slots.defult的含义可查询官网api中的实例属性： https://vuefe.cn/v2/api/#vm-slots ，它得到的是所有没有被包含在具名slot中的节点。由此render函数渲染出新节点。附createElement函数的定义：123456789101112131415161718// @returns &#123;VNode&#125;createElement( //第一个参数： &#123;String | Object | Function&#125;.（必填项） // 一个 HTML 标签，组件设置，或一个函数 // 必须 Return 上述其中一个，例如"div" // 第二个参数：&#123;Object&#125; // 一个对应属性的数据对象.（可选项） //例如，样式属性：&#123;style: &#123;color: 'red',fontSize: '20px'&#125;&#125; //第三个参数： &#123;String | Array&#125; // 子节点(VNodes).（可选项） //例如： // [ // createElement('h1', 'hello world'), //"&lt;p&gt;哈哈哈&lt;/p&gt;" //] //这里我们可以传入数组，也可以直接传入一段节点中的文本内容（String），实际上节点内的文本内容也属于它的子节点。 在render函数中我们可以直接使用原生js来实现v-if、v-for等指令。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个例子学习Vue2.0组件]]></title>
    <url>%2F2018%2F03%2F25%2F%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%AD%A6%E4%B9%A0Vue2.0%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[先看例子效果，是个简单的选择输入框： 这个例子将Vue组件的学习简化为三部分： 组件注册（全局注册和局部注册） 组件组合（父子组件间的通信） 组件复用（Prop、事件、插槽）1、组件注册全局注册和局部注册官方文档已经给出了全局注册和局部注册的实例代码：全局注册1234// 注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;) 局部注册12345678var vm = new Vue(&#123;//声明一个vue实例 el: '#main', components: &#123;//在实例中注册组件 'my-component': &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' &#125; &#125;&#125; 使用局部注册的组件只能在其所在实例中使用。本例中使用局部注册的方式来注册组件。为方便接下来的父子组件间通信的学习，将下拉列表块作为单独的子组件注册，整个选择输入框是它的父组件。123456789101112131415161718192021var Father = &#123;//父组件，在template中使用子组件&lt;child-component&gt;&lt;/child-component&gt; data:function()&#123;//组件中的data必须写成函数形式 return &#123; value:"" &#125; &#125;, template:'&lt;div class="fatherCom"&gt;&lt;div&gt;&lt;input type="text" v-model="value" /&gt;&lt;div class="triangle_border_down"&gt;&lt;span class="up"&gt;&lt;/span&gt;&lt;span class="down"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;', components:&#123;//在父组件中注册子组件 'child-component': &#123; template:'&lt;div class="panel"&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;' &#125; &#125;&#125;//创建一个vue实例var vm = new Vue(&#123; el: '#main', components: &#123;//注册父组件 'father-component': Father &#125;&#125;) html部分：123&lt;div id="main"&gt; &lt;father-component class="center"&gt;&lt;/father-component&gt;&lt;/div&gt; 2、组件组合父子组件间的通信官方文档总结得很清楚：在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。 父组件通过prop将数据传递给子组件我们希望从外部将下拉列表的数据传给父组件，父组件再将它下发给子组件，使用prop完成这个过程。首先在实例中定义city的值，并传入父组件：12345678910111213&lt;div id="main"&gt; &lt;father-component class="center" v-bind:list="city"&gt;&lt;/father-component&gt;&lt;!-- 绑定属性list的值为city --&gt;&lt;/div&gt;var vm = new Vue(&#123; el: '#main', components: &#123; 'father-component': Father &#125;, data:&#123; city:["北京","上海","杭州","广州"]//初始化city的值 &#125; &#125;) 父子组件中使用prop,父组件在使用子组件的地方绑定传入的列表值，子组件使用v-for将列表值显示出来:123456789101112131415var Father = &#123;//父组件，在template中使用子组件&lt;child-component&gt;&lt;/child-component&gt; props:['list'], data:function()&#123;//组件中的data必须写成函数形式 return &#123; value:"" &#125; &#125;, template:'&lt;div class="fatherCom"&gt;&lt;div&gt;&lt;input type="text" v-model="value" /&gt;&lt;div class="triangle_border_down"&gt;&lt;span class="up"&gt;&lt;/span&gt;&lt;span class="down"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;child-component v-bind:list="list"&gt;&lt;/child-component&gt;&lt;/div&gt;', components:&#123;//在父组件中注册子组件 'child-component': &#123; props:['list'], template:'&lt;div class="panel"&gt;&lt;ul&gt;&lt;li v-for="item in list" v-bind:value="list.item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;' &#125; &#125;&#125; 这时我们只要改变外部定义的city的值，子组件中列表值也会改变。 子组件通过vue的自定义事件系统与父组件进行通信我们想要实现点击子组件的列表项时，就将该列表项的值传到父组件输入框里，即改变父组件中定义的value的值（input已于value建立双向数据绑定）。每个vue实例都实现了事件接口： 使用 $on(eventName) 监听事件 使用 $emit(eventName, optionalPayload) 触发事件首先在注册子组件时，为每个列表项绑定一个点击事件childFun，在childFun中我们将触发父组件的tempFun事件，同时将列表项的值传过去。123456789'child-component': &#123; props:['list'], template:'&lt;div class="panel"&gt;&lt;ul&gt;&lt;li v-for="item in list" v-on:click="childFun(item)" v-bind:value="list.item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;', methods:&#123; childFun:function(value)&#123; this.$emit('tempFun',value); &#125; &#125; &#125; 在父组件中监听tempFun事件是否被触发，一旦被触发将调用fatherFun方法更新value的值。12345678910111213141516171819202122232425var Father = &#123;//父组件，在template中使用子组件&lt;child-component&gt;&lt;/child-component&gt; props:['list'], data:function()&#123;//组件中的data必须写成函数形式 return &#123; value:"" &#125; &#125;, template:'&lt;div class="fatherCom"&gt;&lt;div&gt;&lt;input type="text" v-model="value" /&gt;&lt;div class="triangle_border_down"&gt;&lt;span class="up"&gt;&lt;/span&gt;&lt;span class="down"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;child-component v-bind:list="list" v-on:tempFun="fatherFun"&gt;&lt;/child-component&gt;&lt;/div&gt;', components:&#123;//在父组件中注册子组件 'child-component': &#123; props:['list'], template:'&lt;div class="panel"&gt;&lt;ul&gt;&lt;li v-for="item in list" v-on:click="childFun(item)" v-bind:value="list.item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;', methods:&#123; childFun:function(value)&#123; this.$emit('tempFun',value); &#125; &#125; &#125; &#125;, methods:&#123; fatherFun:function(item)&#123; this.value = item; &#125; &#125;&#125; 效果： 用同样的思路完善一下代码，实现：监听输入框的输入值，当手动输入值时将列表显现出来，将手动将输入值清空时列表自动隐藏；当输入框隐藏时，右边的三角形的尖角指向下，当输入框显现时，右边的三角形的尖角指向上。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Father = &#123; props:['list'], data:function()&#123; return &#123; value:"", isShow:false, spanDownShow:true, spanUpShow:false &#125; &#125;, template:'&lt;div class="fatherCom"&gt;&lt;div&gt;&lt;input type="text" v-model="value" /&gt;&lt;div class="triangle_border_down" v-on:click="showPanel"&gt;&lt;span class="up" v-show="spanUpShow"&gt;&lt;/span&gt;&lt;span class="down" v-show="spanDownShow"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;child-component v-bind:list="list" v-on:tempFun="fatherFun" v-show="isShow"&gt;&lt;/child-component&gt;&lt;/div&gt;', components:&#123; 'child-component': &#123; props:['list'], template:'&lt;div class="panel"&gt;&lt;ul&gt;&lt;li v-for="item in list" v-on:click="childFun(item)" v-bind:value="list.item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;', methods:&#123; childFun:function(value)&#123; this.$emit('tempFun',value); &#125; &#125; &#125; &#125;, methods:&#123; fatherFun:function(item)&#123; this.value = item; &#125;, showPanel:function()&#123; this.isShow = !this.isShow; this.spanDownShow = !this.spanDownShow; this.spanUpShow = !this.spanUpShow; &#125; &#125;, watch:&#123; value:function(newValue,oldValue)&#123; if(newValue === "")&#123; this.isShow = false; this.spanDownShow = true; this.spanUpShow = false; &#125;else&#123; this.isShow = true; this.spanDownShow = false; this.spanUpShow = true; &#125; &#125; &#125; &#125; var vm = new Vue(&#123; el: '#main', components: &#123; 'father-component': Father &#125;, data:&#123; city:["北京","上海","杭州","广州"] &#125; &#125;) 3、组件复用Vue 组件的 API 来自三部分——prop、事件和插槽： prop允许外部环境传递数据给组件当我们在vue实例中使用多个输入选择框组件时，可以通过传入不同的列表值使每个输入选择框的下拉列表值都不一样。 事件允许从组件内触发外部环境的副作用同子组件触发父组件的事件，也可通过$emit从父组件内部触发外部环境的function。 插槽允许外部环境将额外的内容组合在组件中使用接口分发内容，最初在中的内容为备用内容，当没有内容被插入时才显示备用内容。示例：我们使用父组件时想加上一段话：123&lt;father-component class="center" v-bind:list="city"&gt; &lt;p&gt;使用插槽&lt;/p&gt; &lt;/father-component&gt; 父组件的template改为：1template:'&lt;div class="fatherCom"&gt;&lt;slot&gt;没有内容哦&lt;/slot&gt;&lt;div&gt;&lt;input type="text" v-model="value" /&gt;&lt;div class="triangle_border_down" v-on:click="showPanel"&gt;&lt;span class="up" v-show="spanUpShow"&gt;&lt;/span&gt;&lt;span class="down" v-show="spanDownShow"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;child-component v-bind:list="list" v-on:tempFun="fatherFun" v-show="isShow"&gt;&lt;/child-component&gt;&lt;/div&gt;' 页面渲染结果是：父子组件间的插槽使用同上。更多插槽相关知识请查看官方文档。demo源码地址：https://github.com/Lizer1995/v]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js控制滚动条滚动]]></title>
    <url>%2F2018%2F03%2F15%2Fjs%E6%8E%A7%E5%88%B6%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[js主要通过4个属性来控制滚动条：scrollHeight: 获取对象可滚动的高度。scrollLeft:获取或设置对象已横向滚动的距离（距左端）。scrollTop:获取或设置对象已纵向滚动的距离。scrollWidth:获取对象可滚动的宽度. 例子：写一个定时器，每隔5秒钟滚动条向下滚动对象可视区域的高度，若滚动到了底部，则自动回到顶端。1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #main&#123; height:500px; overflow-y:scroll; &#125; #div&#123; height:2000px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.onload=function()&#123; setInterval(function()&#123; var hScrollTop = document.getElementById('main').scrollTop; var hScrollHeight = document.getElementById('main').scrollHeight; var height = document.getElementById('main').offsetHeight; console.log(hScrollTop+" "+hScrollHeight+" "+height); if((height+hScrollTop)&gt;=hScrollHeight)&#123;//滚动条已经到了容器底部 document.getElementById('main').scrollTop=0; &#125;else&#123; var h = hScrollTop + height; document.getElementById('main').scrollTop=h; &#125; &#125;,5000); &#125; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less学习总结]]></title>
    <url>%2F2018%2F03%2F01%2FLess%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、Less是什么Less类似于jQuery。——是一种css动态语言，属于css预处理语言的一种。它使用类似css的语法，为css赋予动态语言的特性，如变量、继承、函数、运算等，更方便css的维护与编写。 2、注释/**/ ：编译时保留，编译后的css文件中也能看到注释//：编译时忽略，编译后的css文件中看不到 3、定义变量用符号@来定义变量 例定义：@width:300px;使用：.box{width:@width;} 4、混合编写可重用样式例：1234567.border&#123; border:solid 5px #fff;&#125;.box&#123; .border; margin:10px;&#125; 5、带参数的混合例：123456.border(@border_width)&#123; border:solid @border_width #fff;&#125;.test&#123; .border(30px);&#125; 6、带默认值的混合例：123456.border(@border_width:30px)&#123; border:solid @border_width #fff;&#125;.test&#123; .border();/*不报错，默认传入30px,若传入参数，则参数覆盖默认值*/&#125; 7、匹配模式例：12345678910111213.position(r)&#123; position:relative;/*相对定位*/&#125;.position(a)&#123; position:absolute;/*绝对定位*/&#125;.position(f)&#123; position:fixed;/*静止*/&#125;.test&#123; .postion(a);/*使用绝对定位*/&#125; 8、运算12@width:300px;.box&#123;width:@width+20px;&#125; 9、嵌套例：1234567li&#123; a&#123; color:#ff0000; &amp;:hover&#123;#color:#0000ff;&#125;/*&amp;代表它的上一层选择器*/ &#125; span:&#123;color:#00ff00&#125;&#125; 相当于：123li a&#123;color:#ff0000;&#125;li a:hover&#123;color:#0000ff;&#125;li span&#123;color:#00ff00&#125; 10、@arguments变量@arguments包含了传进来的所有参数。例：123.test_border(@color:#fff,@so:solid,@width:30px)&#123; border:@arguments;&#125; 11、避免编译语法：~&#39;&#39; ######更多语法可查阅less官网。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css让背景图片居中显示的方法]]></title>
    <url>%2F2017%2F12%2F12%2FCSS%E8%AE%A9%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当我们的背景图片写成：1background: url(&quot;images/titleborder.png&quot;) no-repeat; 时，表示背景图片不重复，位置会默认为在div中居于左上角。例：12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #header &#123; width: 100%; height: 400px; border: 1px solid; background: url(&quot;images/titleborder.png&quot;) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果： 如果背景图片写成：1background: url(&quot;images/titleborder.png&quot;) center center no-repeat; 效果是水平垂直居中对齐： 第一个center表示水平居中，第二个center表示垂直居中。要令背景图片水平居中，并贴近div顶部，代码可以这么写：1background: url(&quot;images/titleborder.png&quot;) center 0 no-repeat; 或者：1background: url(&quot;images/titleborder.png&quot;) center top no-repeat; 效果： 令背景图片居于右上角的写法：1background: url(&quot;images/titleborder.png&quot;) right top no-repeat; 效果： 左居中：1background: url(&quot;images/titleborder.png&quot;) left center no-repeat;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重、对象数组去重]]></title>
    <url>%2F2017%2F11%2F21%2Fjs%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[1、普通数组去重普通数组去重方法一：遍历数组法1234567891011function func1(array)&#123; var temp = [];//临时数组 //遍历当前数组 for(var i=0;i&lt;array.length;i++)&#123; //判断array[i]是否在临时数组中，不在则将array[i]的值复制到temp里 //indexOf()方法可返回某个指定的字符串或数组值在字符串或数组中首次出现的位置，若不在其中则返回-1 if (temp.indexOf(array[i]) === -1) temp.push(array[i]); &#125; return temp;&#125; 方法二：排序法1234567891011function func2(array)&#123; var temp = [];//临时数组 array.sort();//先给当前数组排序 temp.push(array[0]); //因为数组已经经过排序，所以重复元素一定相邻，判断当前数组第i个元素与temp的最后一个元素是否相等，不相等时才复制元素 for(var i=1;i&lt;array.length;i++)&#123; if(array[i] != temp[temp.length-1]) temp.push(array[i]); &#125; return temp;&#125; 方法三：对象法123456789101112function func3(array)&#123; var temp = [];//临时数组 var json = &#123;&#125;;//创建一个空对象 //将当前数组的元素值当作对象的属性，遍历数组，比对对象，如果对象的这个属性不存在则将当前数组元素复制到临时数组，并添加该属性且将属性值赋值为1 for(var i = 0; i&lt;array.length; i++)&#123; if(!json[array[i]])&#123;//如果对象没有该属性 temp.push(array[i]); json[array[i]] = 1;//添加属性，将属性值赋值为1 &#125; &#125; return temp;&#125; 2、对象数组去重方法一：将对象数组中name属性相同的项去重1234567891011121314function func4(objArray) &#123; var result = [];//去重后返回的结果数组 var temp = &#123;&#125;;//临时对象 //将对象数组中每一项的name值作为属性，若temp不拥有此属性时则为temp添加此属性且将其值赋为true，并将这一项push到结果数组中 for(var i=0;i&lt;objArray.length;i++)&#123; var myname = objArray[i].name; if(temp[myname])&#123;//如果temp中已经存在此属性名，则说明遇到重复项 continue;//不继续执行接下来的代码，跳转至循环开头 &#125; temp[myname] = true;//为temp添加此属性（myname）且将其值赋为true result.push(objArray[i]);//将这一项复制到结果数组result中去 &#125; return result; &#125; 方法二：使用reduce方法将对象数组中name属性相同的项去重1234567891011function func5(objArray)&#123; var hash = &#123;&#125;; //reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。 objArray = objArray.reduce(function(item, next) &#123;//这是针对数组项操作的函数，对于每个数组项，reduce方法都会将其调用一次 //可使用最多四个参数来声明回调函数（第一个参数：通过上一次调用回调函数获得的值;第二个参数：当前数组元素的值；第三个参数：当前数组元素的数字索引；第四个参数：包含该元素的数组对象） //这里只使用了两个参数，所以item和next分别代表上一次调用回调函数后的值和objArray项值 hash[next.name]?'':hash[next.name]=true&amp;&amp;item.push(next);//与func3逻辑相似 return item; &#125;, []);//初始值是一个空对象，使用reduce方法返回的是空对象通过叠加执行之后的结果 return objArray;&#125; 3、代码汇总与执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!doctype html&gt;&lt;title&gt;&lt;/title&gt;&lt;body&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;(function()&#123; array = [1,2,3,3,3];//测试数组 objArray = [&#123;age:1,name:'a'&#125;,&#123;age:2,name:'a'&#125;,&#123;age:3,name:'c'&#125;];//测试对象数组 console.log(func1(array));//遍历数组法 console.log(func2(array));//排序法 console.log(func3(array));//对象法 console.log(func4(objArray));//将对象数组中name属性相同的项去重 console.log(func5(objArray));//使用数组内置的reduce方法将对象数组中name属性相同的项去重&#125;)()//遍历数组法function func1(array)&#123; var temp = [];//临时数组 //遍历当前数组 for(var i=0;i&lt;array.length;i++)&#123; //判断array[i]是否在临时数组中，不在则将array[i]的值复制到temp里 //indexOf()方法可返回某个指定的字符串或数组值在字符串或数组中首次出现的位置，若不在其中则返回-1 if (temp.indexOf(array[i]) === -1) temp.push(array[i]); &#125; return temp;&#125;//排序法function func2(array)&#123; var temp = [];//临时数组 array.sort();//先给当前数组排序 temp.push(array[0]); //因为数组已经经过排序，所以重复元素一定相邻，判断当前数组第i个元素与temp的最后一个元素是否相等，不相等时才复制元素 for(var i=1;i&lt;array.length;i++)&#123; if(array[i] != temp[temp.length-1]) temp.push(array[i]); &#125; return temp;&#125;//对象法function func3(array)&#123; var temp = [];//临时数组 var json = &#123;&#125;;//创建一个空对象 //将当前数组的元素值当作对象的属性，遍历数组，比对对象，如果对象的这个属性不存在则将当前数组元素复制到临时数组，并添加该属性且将属性值赋值为1 for(var i = 0; i&lt;array.length; i++)&#123; if(!json[array[i]])&#123;//如果对象没有该属性 temp.push(array[i]); json[array[i]] = 1;//添加属性，将属性值赋值为1 &#125; &#125; return temp;&#125;//将对象数组中name属性相同的项去重function func4(objArray) &#123; var result = [];//去重后返回的结果数组 var temp = &#123;&#125;;//临时对象 //将对象数组中每一项的name值作为属性，若temp不拥有此属性时则为temp添加此属性且将其值赋为true，并将这一项push到结果数组中 for(var i=0;i&lt;objArray.length;i++)&#123; var myname = objArray[i].name; if(temp[myname])&#123;//如果temp中已经存在此属性名，则说明遇到重复项 continue;//不继续执行接下来的代码，跳转至循环开头 &#125; temp[myname] = true;//为temp添加此属性（myname）且将其值赋为true result.push(objArray[i]);//将这一项复制到结果数组result中去 &#125; return result; &#125;//使用reduce方法将对象数组中name属性相同的项去重function func5(objArray)&#123; var hash = &#123;&#125;; //reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。 objArray = objArray.reduce(function(item, next) &#123;//这是针对数组项操作的函数，对于每个数组项，reduce方法都会将其调用一次 //可使用最多四个参数来声明回调函数（第一个参数：通过上一次调用回调函数获得的值;第二个参数：当前数组元素的值；第三个参数：当前数组元素的数字索引；第四个参数：包含该元素的数组对象） //这里只使用了两个参数，所以item和next分别代表上一次调用回调函数后的值和objArray项值 hash[next.name]?'':hash[next.name]=true&amp;&amp;item.push(next);//与func3逻辑相似 return item; &#125;, []);//初始值是一个空对象，使用reduce方法返回的是空对象通过叠加执行之后的结果 return objArray;&#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery操作复选框选中状态，prop()和attr()的区别和使用方法]]></title>
    <url>%2F2017%2F11%2F12%2Fjquery%E5%A4%8D%E9%80%89%E6%A1%86%2F</url>
    <content type="text"><![CDATA[今天写代码遇到一个小小的问题，情况是这样的：我的页面中有两个复选框，我想实现选中一个复选框的同时另一个复选框也被选中，取消选中时亦然。一开始我用的是attr()和removeAttr()的方法，代码如下：1234567891011121314151617181920&lt;input type="checkbox" id="checkbox1" /&gt;&lt;input type="checkbox" id="checkbox2" /&gt;&lt;script&gt; $("#checkbox1").click(function()&#123; var bol = $('#checkbox1').is(':checked'); if(bol)&#123; $('#checkbox2').attr("checked",'check'); &#125;else&#123; $('#checkbox2').removeAttr("checked"); &#125; &#125;) $("#checkbox2").click(function()&#123; var bol = $('#checkbox2').is(':checked'); if(bol)&#123; $('#checkbox1').attr("checked",'check'); &#125;else&#123; $('#checkbox1').removeAttr("checked"); &#125; &#125;)&lt;/script&gt; 后来发现这个方法不行，会有Bug：第一次我选中复选框A，复选框B可以同时自动被选中，取消选中复选框A复选框B也同时取消，好，到这里是没问题的；但如果我这样选择：选中复选框A，复选框B同时自动选中，再点击复选框B来取消选中两个复选框，就没有用了，以后再怎么选中A或选中B，另一个都不为所动。然后我试着换了个方法，使用prop()来替代attr()，代码如下：1234567891011121314151617181920&lt;input type="checkbox" id="checkbox1" /&gt;&lt;input type="checkbox" id="checkbox2" /&gt;&lt;script&gt; $("#checkbox1").click(function()&#123; var bol = $('#checkbox1').is(':checked'); if(bol)&#123; $('#checkbox2').prop("checked",true); &#125;else&#123; $('#checkbox2').prop("checked",false); &#125; &#125;) $("#checkbox2").click(function()&#123; var bol = $('#checkbox2').is(':checked'); if(bol)&#123; $('#checkbox1').prop("checked",true); &#125;else&#123; $('#checkbox1').prop("checked",false); &#125; &#125;)&lt;/script&gt; 完全没问题，无论什么时候A与B的选中状态都是同步的： 这是什么原因呢？到网上查了一下，原理是这样的：“attr”是”attribute”的缩写，表示HTML文档节点的属性，例如：1&lt;input type="checkbox" id="checkbox1" class="mycheckbox" checked="checked" /&gt; 这里面id、class、checked都是input（HTML文档节点）的属性；”prop”是”property”的缩写，表示JS对象的属性，例如：1var student = &#123;name:"张三",age:"18",id:"001"&#125; 这里面name、age、id都是student（JS对象）的属性。在jQuery 1.6之前，只有attr()方法没有prop()方法，1.6及之后的版本增加了prop()方法，所以使用1.6及之后版本的jQuery，操作文档节点的属性和JS对象的属性需要分别使用其对应的方法。jQuery认为：attribute的checked、selected、disabled表示的是标签初始状态的值，所以我在使用attr(&quot;checked&quot;,&#39;check&#39;)方法时，仅仅是为input增加了一个checked的属性，即只设定了该复选框的初始状态为选中状态，而没有改变该复选框的实时选中状态，所以会出现上述Bug。只有property的值才能表示该对象的实时属性，故在我这种情况下使用prop(&quot;checked&quot;,true)才是正确的。最后记录几个使用attr()和prop()时的细节问题： 对于表单元素的checked、selected、disabled等属性，在jQuery 1.6之前，attr()获取这些属性的返回值为Boolean类型，如果被选中(或禁用)就返回true，否则返回false。但是从1.6开始，使用attr()获取这些属性的返回值为String类型，如果被选中(或禁用)就返回”checked”、”selected”或”disabled”，如果不需要这个属性了，应使用removeAttr()将其移除。 1.6及之后请使用prop()来设定表单的实时状态（如：checked、selected、disabled），值为true或false。 1.6及之后attr()设置的值只能是String型的，而prop()设置的值可以是任意数据类型。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（七）服务]]></title>
    <url>%2F2017%2F10%2F12%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[出于内存占用和性能的考虑，控制器只会在需要时被实例化，并且不再需要就会被销毁。这意味着每次切换路由或者重新加载视图时，控制器只会在需要时被实例化，并且不再需要就会被销毁。这意味着每次切换路由或重新加载视图时，当前的控制器会被AngularJS清除掉。 服务提供了一种能够在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。 AngularJS中可以创建自己的服务，也可以使用内置的服务。 AngularJS的五种创建模式：value、constant、factory、service、provider。value() 变量此方法接收两个参数： name（字符串）：需要注册的服务名 value（值）：将这个值作为可注入的实例返回constant() 常量可以将一个已经存在的变量值注册为服务，并将其注入到应用的其他部分当中。例如，假设我们需要给后端服务一个apiKey，可以用constant()将其当做常量保存下来。此方法接收两个参数： name（字符串）：需要注册的服务名 value（值）：将这个值作为可注入的实例返回constant()的值不可被改变factory() 最常用接收两个参数： name（字符串）：需要注册的服务名。 getFn（函数）：会在AngularJS创建服务实例时被调用。service()注册一个支持构造函数的服务，它允许我们为服务注册一个构造函数。接受两个参数： name（字符串）：要注册的服务名称。 constructor（函数）：构造函数，调用它来实例化对象。 服务的应用 在多个控制器中调用服务。 代码示例：12345678910111213141516171819202122232425&lt;body&gt;&lt;div ng-app="myApp"&gt; &lt;div ng-controller="FCtrl"&gt; &lt;input type="text" ng-model="data.msg"&gt; &#123;&#123;data.msg&#125;&#125; &lt;/div&gt; &lt;div ng-controller="SCtrl"&gt; &lt;input type="text" ng-model="data.msg"&gt; &#123;&#123;data.msg&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module('myApp', []); app.factory('Data',function()&#123; return&#123;msg:"我来自factory"&#125; &#125;) app.controller('FCtrl', function($scope,Data) &#123; $scope.data = Data; &#125;); app.controller('SCtrl', function($scope,Data) &#123; $scope.data = Data; &#125;);&lt;/script&gt; 可以看到，我们使用了两个控制器，两个控制器的数据来源都来自Data，所以这段代码的运行结果是两个表单数据，改变一个时另一个也会同时改变。 效果：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（六）依赖注入]]></title>
    <url>%2F2017%2F09%2F28%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[依赖注入是一种设计模式。在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。 引用方式：123var app = angular.module('app',[ 'ngRoute','ngAnimate','Controller','filters','service','derectives']) angularJS在启动的时候就会去检测依赖中的模块有没有被注册或者说有没有被加载进来。如果缺失模块就会报错。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（五）过滤器]]></title>
    <url>%2F2017%2F09%2F27%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器过滤器用来格式化需要展示给用户的数据。AngularJS有很多实用的内置过滤器，同时提供了方便的途径可以自己创建过滤器。 使用方法在HTML中的模板绑定双花括号内通过|来调用过滤器。代码示例：12345//将字符串转化为大写&lt;div&gt; &lt;p&gt;名字 : &lt;input type="text" ng-model="name"&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name|uppercase&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 效果： AngularJS内置过滤器currency将数值格式化为货币格式。 data将日期化为需要的格式。为制定使用格式时，默认medium格式。取当前时间来使用这些格式，当前时间为2017/9/27,15:12。代码示例1：12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;&lt;div ng-app="myApp"&gt; &lt;div ng-controller="MyController"&gt; &lt;h4&gt;日期：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;date | date:'medium'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'short'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'fullDate'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'longDate'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'mediumDate'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'shortDate'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'mediumTime'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;date | date:'shortTime'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;年份：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;year | date:'yyyy'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;year | date:'yy'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;year | date:'y'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;月份：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;month | date:'MMMM'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;month | date:'MMM'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;month | date:'MM'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;month | date:'M'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;日期：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;day | date:'dd'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;day | date:'d'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;day | date:'EEEE'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;day | date:'EEE'&#125;&#125;&lt;/h5&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module('myApp',[]).controller('MyController', function($scope)&#123; var now = new Date();//获取当前系统时间 $scope.date = now; $scope.year = now; $scope.month = now; $scope.day = now; &#125; )&lt;/script&gt; 效果： 代码示例2：1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;div ng-app="myApp"&gt; &lt;div ng-controller="MyController"&gt; &lt;h4&gt;小时：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;hour | date:'HH'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;hour | date:'H'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;hour | date:'hh'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;hour | date:'h'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;分钟&lt;/h4&gt; &lt;h5&gt;&#123;&#123;mimute | date:'mm'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;mimute | date:'m'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;秒数：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;second | date:'ss'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;second | date:'s'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;second | date:'sss'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;字符：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;character | date:'a'&#125;&#125;&lt;/h5&gt; &lt;h5&gt;&#123;&#123;character | date:'Z'&#125;&#125;&lt;/h5&gt; &lt;h4&gt;自定义示例：&lt;/h4&gt; &lt;h5&gt;&#123;&#123;tody | date:'MMMd,y'&#125;&#125;&lt;/h5&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module('myApp',[]).controller('MyController', function($scope)&#123; var now = new Date();//获取当前系统时间 $scope.hour = now; $scope.mimute = now; $scope.second = now; $scope.character = now; $scope.tody = now; &#125; )&lt;/script&gt; 效果： json将一个JSON或者JavaScript对象转换成字符串。 limitTo根据传入的参数生成一个新的数组或字符串，新的数组或字符串的长度取决于传入的参数，通过传入参数的正负值来控制从前面还是从后面开始截取。 lowercase将字符串转为小写。 uppercase将字符串转为大写。 number将字符串转为文本。它的第二个参数是可选的，用来控制小数点后截取的位数。使用方法：1&#123;&#123;12334.2222 | number:2&#125;&#125; orderBy可以用表达式对指定的数组进行排序。 自定义过滤器使用filter自定义过滤器，代码示例：1234567891011121314151617&lt;body&gt;&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;h1&gt;姓名: &#123;&#123; msg | reverse &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.msg = "Runoob"; &#125;); app.filter('reverse', function() &#123; //可以注入依赖 return function(text) &#123; return text.split("").reverse().join("");//split()：把字符串分割成为一个字符串数组；reverse()：颠倒数组中元素顺序；join("")：将数组中所有元素组合成一个字符串 &#125; &#125;);&lt;/script&gt; 效果：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（四）多重视图和路由]]></title>
    <url>%2F2017%2F09%2F26%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%A4%9A%E9%87%8D%E8%A7%86%E5%9B%BE%E5%92%8C%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[多重视图和路由为什么需要路由？回答这个问题首要要简单介绍一下单页面应用。单页面应用通俗来讲就是在浏览器中运行的只有一个html主页面的应用，在使用期间不会重新刷新页面加载数据，所有的数据交互都由AJAX来完成。能够从页面的一个视图跳转到另一个视图，对单页面应用来讲是至关重要的。当应用变得也来越复杂时，我们需要一个合理的方式来管理 用户在使用过程中看到的界面。好的方法是将视图分解为布局与模板视图，根据浏览器访问的URL来展示对应的视图。AngularJS提供声明路由的方法来实现这个功能。 安装与使用要使用路由的功能，需要单独引用angular-route.js模块：12&lt;script src="angular-1.4.9/angular.js"&gt;&lt;/script&gt;&lt;script src="angular-1.4.9/angular-route.js"&gt;&lt;/script&gt; AngularJS下载地址：https://code.angularjs.org/1.4.9/不要忘了把ngRoute模块在我们的应用中当做依赖加载进来：1angular.module('myApp',['ngRoute']); 布局模板创建一个布局模板，需要修改HTML以告诉AngularJS把模板渲染到何处。通过将ng-view指令和路由组合到一起，我们可以精确地指定当前路由所对应的模板在DOM中的渲染位置。例如：123&lt;div&gt; &lt;div ng-view&gt;&lt;/div&gt;&lt;/div&gt; ng-view是由ngRoute模板提供的一个特殊指令，它的独特作用是在HTML中给$route对应的视图内容上占位。它将创建自己的作用域并将模板嵌套在内部。注意：ng-view是个优先级为1000的终极指令，&lt;div ng-view&gt;&lt;/div&gt;元素上的其他指令都是没有意义的。使用config函数在特定的模块或应用中定义路由。代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body ng-app='routeDemo'&gt;&lt;!--左边栏--&gt;&lt;div id="navigator" style="width: 20%;float: left"&gt; &lt;!--菜单--&gt; &lt;ul&gt; &lt;li class="list-group-item"&gt;&lt;a href="#/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class="list-group-item"&gt;&lt;a href="#/woman"&gt;女装&lt;/a&gt;&lt;/li&gt; &lt;li class="list-group-item"&gt;&lt;a href="#/man"&gt;男装&lt;/a&gt;&lt;/li&gt; &lt;li class="list-group-item"&gt;&lt;a href="#/clothes"&gt;上衣&lt;/a&gt;&lt;/li&gt; &lt;li class="list-group-item"&gt;&lt;a href="#/skirt"&gt;裙子&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--右边栏--&gt;&lt;div style="float: left"&gt; &lt;div ng-view=""&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var routeDemo = angular.module('routeDemo',['ngRoute']); routeDemo.config(function($routeProvider)&#123; $routeProvider .when('/',&#123;//用when来添加一个特定的路由，这个方法可以接收两个参数（when(path,route)），第一个参数是路由路径，第二个参数是配置对象 //如果不想再js代码中拼HTML，也可以使用templateURL，传入HTML文件URL，写法如templateURL:'view/one.html'。 template:'&lt;div&gt;首页&lt;/div&gt;' &#125;). when('/woman',&#123; template:'&lt;div&gt;女装&lt;/div&gt;' &#125;). when('/man',&#123; template:'&lt;div&gt;男装&lt;/div&gt;' &#125;). when('/clothes',&#123; template:'&lt;div&gt;上衣&lt;/div&gt;' &#125;). when('/skirt',&#123; template:'&lt;div&gt;裙子&lt;/div&gt;' &#125;) &#125;) .otherwise(&#123;//可以将意外路径进行重定向的捕获器 redirectTo:'/' &#125;)&lt;/script&gt; 效果： when方法的第二个参数：配置对象：配置对象决定了当第一个参数中的路由能够匹配时具体做些什么，配置对象中可以进行设置的属性包括： controller写法：controller:&#39;MyController&#39;或controllor:function($scope){}如果在配置对象中设置了controller属性，那么这个制定的控制器会与路由所创建的新作用域关联在一起。如果参数值是字符型，会在模块中所有注册过得控制器中查找对应的内容，然后与路由关联在一起。如果参数值是函数值，这个函数会作为模板中DOM元素的控制器并与模板进行关联。 template将HTML语句渲染到具有ng-view指令的DOM元素中。 templateUrl会根据路径读取视图将其渲染到具有ng-view指令的DOM元素中。 resolve如果设置了resolve属性，AngularJS会将列表中的元素注入到控制器中。 redirectTo写法：redirectTo:&#39;/home或redirectTo:function(route,path,search)。如果redirectTo属性的值是一个字符串，那么路径会替换成为这个值。如果属性值是一个函数，那么路径会被替换成为函数的返回值。函数的三个参数的意义为：(1)route：从当前路径中提取出的路由参数。(2)path：当前路径(3)search：当前URL中的查询值 reloadOnSearch如果这一属性被设置为true（默认），当$location.search()发生变化时会重新加载路由。如果设置为false，那么URL中的查询串部分发生变化时就不会重新加载路由。这个小窍门对路由嵌套和原地分页等需求十分有用。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（三）控制器和表达式]]></title>
    <url>%2F2017%2F09%2F26%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[控制器AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给作用域对象设置初始状态，并添加自定义行为。当我们在页面上创建一个新的控制器时，AngularJS会生成一个新的$scope给这个控制器。可以在这个控制器里初始化$scope。由于AngularJS会生成并传递一个新的$scope给这个控制器。可以在这个控制器里初始化$scope。由于AngularJS会负责处理控制器的实例化过程，我们只需要编写构造函数即可。 表达式用双花括号将一个变量绑定到$scope上的写法本质上就是一个表达式。当用$watch进行监听时，AngularJS会对表达式或函数进行运算。表达式特性： 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限； 如果表达式发生了TypeError和ReferenceError并不会抛出异常； 不允许使用任何流程控制功能（如if/else）； 可以接受过滤器和过滤器链。对表达式进行任何的操作，都会在其所属作用域的内部执行，因此可以在表达式内部调用那些限制在此作用域内的变量，并进行循环、函数调用、将变量应用到数学式中等操作。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（二）指令系统]]></title>
    <url>%2F2017%2F09%2F26%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[AngularJS指令系统最简单的例子：1234567891011121314&lt;div ng-app="myModule"&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;script&gt; var myModule = angular.module('myModule',[]); myModule.directive("hello",function()&#123; return&#123; restrict:'E', template:'&lt;div&gt;Hi everyone!&lt;/div&gt;', repalce:true &#125; &#125;)&lt;/script&gt; 我们通过指令自定义了一个元素，页面效果为： 打开谷歌浏览器开发者模式，看到里面被替换成为： restrict匹配模式，有四种模式： A：属性 E:元素 M：注释 C：css样式类一般来时模式很少使用。AEC模式的使用方法示例：12345678910111213141516&lt;div ng-app="myModule"&gt; &lt;hello&gt;&lt;/hello&gt;&lt;!-- 元素 E模式 --&gt; &lt;div hello&gt;&lt;/div&gt;&lt;!-- 属性 A属性模式 --&gt; &lt;div class="hello"&gt;&lt;/div&gt;&lt;!-- class样式类 C模式 --&gt;&lt;/div&gt;&lt;script&gt; var myModule = angular.module('myModule',[]); myModule.directive("hello",function()&#123; return&#123; restrict:'AEC', template:'&lt;div&gt;Hi everyone!&lt;/div&gt;', repalce:true &#125; &#125;)&lt;/script&gt; 网页效果： 默认使用A模式。 ######哪种情况下使用哪种模式？ 当需要创建带有自己模板的指令时，使用E模式 当需要为已有的HTML标签增加功能时，使用A模式 template模板template:&#39;&lt;div&gt;Hi everyone!&lt;/div&gt;&#39;是我们最终在页面上呈现出来的内容。如果内容较多时，我们可以把模板单独写在一个html中，再用templateUrl引入，写法为：templateUrl:&#39;hello.html&#39; transclude变换当我们用指令自定义一个标签时，又在标签里面嵌套了一段内容时，我们自定义的标签内容往往会把原有内容替换，我们可以使用transclude来避免这样的情况出现。123456789101112131415&lt;div ng-app="myModule"&gt; &lt;hello&gt; &lt;div&gt;指令内嵌套的内容&lt;/div&gt; &lt;/hello&gt;&lt;/div&gt;&lt;script&gt; var myModule = angular.module('myModule',[]); myModule.directive("hello",function()&#123; return&#123; restrict:'E', template:'&lt;div&gt;Hi everyone!&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;', transclude:true &#125; &#125;)&lt;/script&gt; 页面效果： replace相反的，如果我们想把标签里面的所有内容全部替换掉，我们可以设置replace=true。123456789101112131415&lt;div ng-app="myModule"&gt; &lt;hello&gt; &lt;div&gt;指令内嵌套的内容&lt;/div&gt; &lt;/hello&gt;&lt;/div&gt;&lt;script&gt; var myModule = angular.module('myModule',[]); myModule.directive("hello",function()&#123; return&#123; restrict:'E', template:'&lt;div&gt;Hi everyone!&lt;/div&gt;', replace:true &#125; &#125;)&lt;/script&gt; 效果： link用link函数创建可操作DOM的指令。代码示例：1234567891011121314151617181920212223242526&lt;div ng-app="myModule"&gt; &lt;div ng-controller = "MyCtrl"&gt; &lt;loader&gt;加载数据&lt;/loader&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var myModule = angular.module('myModule',[]); myModule.controller('MyCtrl',['$scope',function($scope)&#123; $scope.loadData = function()&#123; console.log("加载数据中……"); &#125; &#125;]); myModule.directive("loader",function()&#123; return&#123; restrict:'AE', link:function(scope,element,attr)&#123; element.bind("click",function()&#123;//绑定点击事件 scope.loadData();//控制器中定义的方法 &#125;) &#125; &#125; &#125;)&lt;/script&gt; 可见，通过link函数我们给元素绑定了一个点击事件。效果： 点击之后，控制台中显示：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记（一）模块、作用域、双向数据绑定]]></title>
    <url>%2F2017%2F09%2F25%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%A8%A1%E5%9D%97%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[AngularJS四大核心特性：MVC、模块化、指令系统、双向数据绑定。 MVC 好处：职责清晰，代码模块化，可复用（特别是Model和View）。 模块一切都是从模块开始。一个应用可包含多个模块，每一个模块都包含了定义具体功能的代码。使用模块的好处： 保持全局命名空间的清洁 编写测试代码更容易，并能保持其清洁，以便更容易找到相互隔离的功能 易于在不同应用间复用代码 使应用能够以任意顺序加载代码的各个部分使用angular.module()的方法来声明模块：12//接受两个参数，第一个是模块的名称，第二个是依赖列表，即可以被注入到模块中的对象列表。angular.module('myApp',[]); 如果调用这个方法时只传递一个参数，那么该方法只用来引用该模块：12//引用名为myApp的模块angular.module('myApp'); 作用域作用域是什么？ 是表达式执行的上下文 是定义应用业务逻辑、控制器方法和视图属性的地方 是视图和控制器之间的胶水，在应用将视图渲染并呈现给用户之前，视图中的模板和作用域进行连接，然后应用会对DOM进行设置以便将属性变化通知给AngularJS 作用域提供了监视数据模型变化的能力 将应用的业务逻辑都放在控制器中，将相关的数据都放在控制器的作用域中，是比较完美的架构 $scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样，$scope并不负责处理和操作数据，它只是视图和HTML之间的桥梁，它的所有属性都可以自动被视图访问到 关于作用域的简单代码：12345678910&lt;body&gt; &lt;div ng-app="myApp"&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module('myApp',[]).run(function($rootScope)&#123;//$rootScope是所有$scope对象的最上层，AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定 $rootScope.name = "World" &#125;)&lt;/script&gt; 运行结果： 但在实际情况中，我们一般不会在$rootScope上附加业务逻辑，以免污染全局作用域。我们可以用控制器创建一个隔离的子$scope对象：1234567891011121314&lt;body&gt; &lt;div ng-app="myApp"&gt; &lt;div ng-controller="MyController"&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module('myApp',[]).controller('MyController', function($scope)&#123; $scope.name = "World"; &#125; )&lt;/script&gt; 运行结果同上。 作用域的基本功能有： 提供观察者以监视数据模型的变化 可以将数据模型的变化通知给整个应用，甚至是系统外的组件 可以进行嵌套，隔离业务功能和数据 给表达式提供运算时所需的执行环境 $scope对象的生命周期处理有四个不同阶段： 创建创建新控制器或指令时，AngularJS会创建一个新的作用域。 链接当AngularJS开始运行时，所有的$scope对象都会附加或者链接到视图中。 更新当事件循环运行时，它通常执行在$rootScope对象上，每个子作用域都执行自己的脏值检测。 销毁当一个$scope在视图中不再需要时，这个作用域会清理和销毁自己。 双向数据绑定简单来说双向数据绑定可以总结为下图： 数据绑定使我们可以将视图理解为模型状态的映射，当客户端的数据模型发生变化时，视图就能反映出这些变化。AngularJS会记录数据模型所包含的数据在任何特定时间的值，而非初始值。当AngularJS认为某个值可能发生变化的时候，它会运行自己的事件循环来检查这个值是否变“脏”，如果该值从上次事件循环运行之后发生了变化，则该值会被认为是“脏”值，这个过程被称作脏检查。AngularJS会在事件循环时执行脏检查来保证数据的一致性。 简单的双向数据绑定小例子：1234&lt;div ng-app=""&gt; &lt;p&gt;名字 : &lt;input type="text" ng-model="name"&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 效果：]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
</search>
